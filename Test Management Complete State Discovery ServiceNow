/*
 * --- Script Metadata ---
 * Name:          Improved Test Management State Discovery (v.3.0)
 * Version:       3.0
 * Modified:      2025-09-29
 * Required role: admin
 * Author:        Brian Gadeberg Buur (Concept) & Claude (Implementation)
 * Description:   Enhanced discovery script that checks both direct fields AND inherited fields from parent tables
 * 
 * IMPROVEMENTS:
 * - Checks for inherited state fields from parent tables
 * - Validates actual records to confirm state field presence
 * - More thorough dictionary analysis
 * - Better error handling for field detection
 */

(function() {
    'use strict';

    function log(message, level) {
        var timestamp = new GlideDateTime().getDisplayValue();
        gs.warn('[TM_STATE_DISCOVERY_v3] ' + timestamp + ' - ' + level.toUpperCase() + ': ' + message);
    }

    /**
     * Enhanced function to check if a table has a state field (including inherited)
     */
    function hasStateField(tableName) {
        // Method 1: Check dictionary (direct and inherited)
        var grDict = new GlideRecord('sys_dictionary');
        grDict.addQuery('name', tableName);
        grDict.addQuery('element', 'state');
        grDict.query();
        
        if (grDict.next()) {
            return {
                hasField: true,
                source: 'direct',
                fieldInfo: {
                    type: grDict.getValue('internal_type'),
                    choiceList: grDict.getValue('choice'),
                    defaultValue: grDict.getValue('default_value'),
                    mandatory: grDict.getValue('mandatory'),
                    readOnly: grDict.getValue('read_only')
                }
            };
        }

        // Method 2: Check if table extends another table that has state field
        var grTableDef = new GlideRecord('sys_db_object');
        grTableDef.addQuery('name', tableName);
        grTableDef.query();
        
        if (grTableDef.next()) {
            var superClass = grTableDef.getValue('super_class');
            if (superClass) {
                log('Checking parent table: ' + superClass.getDisplayValue() + ' for ' + tableName, 'info');
                var parentResult = hasStateField(superClass.getDisplayValue());
                if (parentResult.hasField) {
                    return {
                        hasField: true,
                        source: 'inherited from ' + superClass.getDisplayValue(),
                        fieldInfo: parentResult.fieldInfo
                    };
                }
            }
        }

        // Method 3: Test with actual record if table has data
        try {
            var grTest = new GlideRecord(tableName);
            grTest.setLimit(1);
            grTest.query();
            
            if (grTest.next()) {
                if (grTest.isValidField('state')) {
                    return {
                        hasField: true,
                        source: 'detected in record',
                        fieldInfo: {
                            type: 'detected',
                            choiceList: 'unknown',
                            defaultValue: 'unknown',
                            mandatory: 'unknown',
                            readOnly: 'unknown'
                        }
                    };
                }
            }
        } catch (e) {
            log('Error testing record for ' + tableName + ': ' + e.message, 'warn');
        }

        return {hasField: false, source: 'not found', fieldInfo: null};
    }

    /**
     * Enhanced table state analysis
     */
    function discoverTableStates(tableName, tableLabel) {
        log('\n========================================', 'info');
        log('ANALYZING TABLE: ' + tableLabel + ' (' + tableName + ')', 'info');
        log('========================================', 'info');
        
        if (!gs.tableExists(tableName)) {
            log('Table does not exist in this instance!', 'warn');
            return;
        }
        
        var stateFieldResult = hasStateField(tableName);
        
        if (!stateFieldResult.hasField) {
            log('No state field found on this table', 'info');
            return;
        }
        
        log('STATE FIELD FOUND: ' + stateFieldResult.source, 'info');
        
        // Dictionary Configuration
        log('\n--- Dictionary Configuration ---', 'info');
        if (stateFieldResult.fieldInfo) {
            log('Field Type: ' + stateFieldResult.fieldInfo.type, 'info');
            log('Choice List ID: ' + stateFieldResult.fieldInfo.choiceList, 'info');
            log('Default Value: ' + (stateFieldResult.fieldInfo.defaultValue || '(none)'), 'info');
            log('Mandatory: ' + stateFieldResult.fieldInfo.mandatory, 'info');
            log('Read Only: ' + stateFieldResult.fieldInfo.readOnly, 'info');
        }
        
        // Choice List Values - Check both table-specific and inherited
        log('\n--- Choice List Values ---', 'info');
        var grChoice = new GlideRecord('sys_choice');
        grChoice.addQuery('name', tableName);
        grChoice.addQuery('element', 'state');
        grChoice.orderBy('sequence');
        grChoice.query();
        
        var stateMap = {};
        var stateCount = 0;
        
        log('Format: [Seq] Value -> Label (Inactive: Y/N)', 'info');
        while (grChoice.next()) {
            stateCount++;
            var value = grChoice.getValue('value');
            var label = grChoice.getValue('label');
            var sequence = grChoice.getValue('sequence');
            var inactive = grChoice.getValue('inactive');
            
            stateMap[value] = label;
            log('[' + sequence + '] "' + value + '" -> "' + label + '" (Inactive: ' + (inactive === 'true' ? 'Y' : 'N') + ')', 'info');
        }
        
        // If no table-specific choices, check parent table choices
        if (stateCount === 0 && stateFieldResult.source.indexOf('inherited') >= 0) {
            var parentTable = stateFieldResult.source.split(' from ')[1];
            if (parentTable) {
                log('Checking parent table choices from: ' + parentTable, 'info');
                var grParentChoice = new GlideRecord('sys_choice');
                grParentChoice.addQuery('name', parentTable);
                grParentChoice.addQuery('element', 'state');
                grParentChoice.orderBy('sequence');
                grParentChoice.query();
                
                while (grParentChoice.next()) {
                    stateCount++;
                    var value = grParentChoice.getValue('value');
                    var label = grParentChoice.getValue('label');
                    var sequence = grParentChoice.getValue('sequence');
                    var inactive = grParentChoice.getValue('inactive');
                    
                    stateMap[value] = label;
                    log('[' + sequence + '] "' + value + '" -> "' + label + '" (Inherited, Inactive: ' + (inactive === 'true' ? 'Y' : 'N') + ')', 'info');
                }
            }
        }
        
        if (stateCount === 0) {
            log('No choice values found for state field!', 'warn');
        }
        
        // Current Usage with better aggregate handling
        log('\n--- Current Usage Statistics ---', 'info');
        try {
            var grTable = new GlideRecord(tableName);
            grTable.addAggregate('COUNT');
            grTable.groupBy('state');
            grTable.query();
            
            var totalRecords = 0;
            var usageFound = false;
            
            while (grTable.next()) {
                usageFound = true;
                var stateValue = grTable.getValue('state');
                var count = parseInt(grTable.getAggregate('COUNT')) || 0;
                var stateLabel = stateMap[stateValue] || '(Unknown Label)';
                
                totalRecords += count;
                log('State: "' + stateValue + '" (' + stateLabel + ') - Count: ' + count, 'info');
            }
            
            if (!usageFound) {
                log('No records found in table', 'info');
            } else {
                log('Total Records: ' + totalRecords, 'info');
            }
            
        } catch (e) {
            log('Error querying table: ' + e.message, 'error');
        }
        
        // Sample Records
        log('\n--- Sample Records (First 3) ---', 'info');
        try {
            var grSample = new GlideRecord(tableName);
            grSample.setLimit(3);
            grSample.orderByDesc('sys_created_on');
            grSample.query();
            
            var sampleCount = 0;
            while (grSample.next()) {
                sampleCount++;
                var stateValue = grSample.getValue('state');
                var stateDisplay = grSample.getDisplayValue('state');
                var recordName = grSample.getValue('short_description') || grSample.getValue('name') || grSample.getValue('number') || grSample.getDisplayValue();
                
                log('Record: "' + recordName + '"', 'info');
                log('  State Value: "' + stateValue + '", Display: "' + stateDisplay + '"', 'info');
                log('  Created: ' + grSample.getValue('sys_created_on'), 'info');
            }
            
            if (sampleCount === 0) {
                log('No sample records to display', 'info');
            }
            
        } catch (e) {
            log('Error sampling records: ' + e.message, 'error');
        }
    }

    try {
        log('Starting Enhanced Test Management State Discovery v3.0', 'info');
        
        // Focus on the key tables we need
        var tablesToCheck = [
            {name: 'sn_test_management_test_plan', label: 'Test Plans'},
            {name: 'sn_test_management_test_cycle', label: 'Test Cycles'},
            {name: 'sn_test_management_test_execution_suite', label: 'Test Execution Suites'},
            {name: 'sn_test_management_test', label: 'Tests'},
            {name: 'sn_test_management_test_version', label: 'Test Versions'}
        ];
        
        // Analyze each table
        for (var i = 0; i < tablesToCheck.length; i++) {
            var table = tablesToCheck[i];
            discoverTableStates(table.name, table.label);
        }
        
        log('\n=== ENHANCED DISCOVERY COMPLETE ===', 'info');
        
    } catch (e) {
        log('CRITICAL ERROR: ' + e.message, 'error');
        log('Stack trace: ' + e.stack, 'error');
    }

})();
